"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import time


def time_counter(func):
    def wrapper(*args):
        start = time.perf_counter()
        result = func(*args)
        finish = time.perf_counter()
        print(f'Time for function "{func.__name__}" = {finish - start}.')
        return result

    return wrapper


# (A) заполнение списка/словаря O(n)

@time_counter
def my_list(new_list=[]):
    for i in range(100000):  # O(n) - линейная
        new_list.append(i)  # O(1) - константная


@time_counter
def my_dict(new_dict={}):
    for i in range(100000):  # O(n) - линейная
        new_dict[i] = str(i)  # O(1) - константная


# my_list()
# my_dict()

""" 
АНАЛИТИКА
Список заполняется быстрей, поскольку ему не приходится выполнять хэширование.
Результаты по времени меняются в зависимости от работы системы. 
Примерный результат работы:
Time for function "my_list" = 0.005960799999999999.
Time for function "my_dict" = 0.019206900000000002.
"""

# (B) получение элемента списка/словаря O(n)

test_list = []
test_dict = {}

for i in range(1000000):  # заполняем test_list/test_dict
    test_list.append(i)
    test_dict[i] = str(i)


@time_counter
def get_list_el(lst, n):
    for i in lst:  # О(n) - линейная
        if i == n:  # О(n) - константная
            return lst[i]  # О(n) - константная


@time_counter
def get_dict_el(dct, n):
    for key in dct:  # O(n) - линейная
        if key == n:  # О(1) - константная
            return dct[key]  # O(1) - константная


# get_list_el(test_list, 772850)
# get_dict_el(test_dict, 772850)

"""
АНАЛИТИКА
В теории, получение элемента из словаря должно происходить быстрее, т.к. он является 
хэш-таблицей. Но т.к. по условию мы используем цикл - разница во времени с получением 
элемента из списка практически не заметна.
Пример работы:
Time for function "get_list_el" = 0.014478099999999994.
Time for function "get_dict_el" = 0.015071500000000015.
"""


# (C) удаление элемента списка/словаря О(n)

@time_counter
def pop_list_el(lst=[]):
    for i in range(len(lst)):  # O(n) - линейная
        lst.pop()  # O(1) - константная


@time_counter
def pop_dict_el(dct={}):
    for i in range(len(dct)):  # O(n) - линейная
        del dct[i]  # O(1) - константная


pop_list_el(test_list)
pop_dict_el(test_dict)

"""
АНАЛИТИКА
И опять же таки, при прочих равных (из-за использования цикла) особой разницы во времени
при удалении объектов из словаря и списка не замечено. При большом (относительно) количестве
запуска кода быстрей выполняется то одно, то другое удаление.
Time for function "pop_list_el" = 0.07093569999999999.
Time for function "pop_dict_el" = 0.06300239999999996.
"""
